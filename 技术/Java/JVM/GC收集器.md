## 新生代收集器
### Serial New
- 单线程收集器，工作时必须暂停其他线程；
- 简单高效，没有线程交互开销；
- 基于复制算法；

### Parallel New
- 对Serial的改进，多线程；
- CPU数量<4时，性能并不比Serial好；
- CMS新生代的默认收集器；
- 基于复制算法；

### Parallel Scavenge
- 复制算法；
- 更关注吞吐量，吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)；
- 不能和CMS配合工作



## 老年代收集器

### Serial Old
- 标记-整理算法
- 单线程，性能不行；

### Parallel Old
- Serial Old的多线程版本；
- 标记-整理算法；

### CMS Concurrent Mark Sweep
- 标记-清除算法；
- 并发收集器；
**缺点**
- 产生内存碎片较多；
- 产生浮动垃圾；
- 并发执行，占用CPU；

#### CMS收集过程
1. 初始标记：stop the world，只是做GC Root可达性的初始标记
2. 并发标记：耗时较长，但可以与用户线程并发执行；
3. 重新标记：stop the world，标记2中变动的对象；
4. 并发清除：耗时较长，但可以与用户线程并发执行；



## 非分代收集器

### G1 Garbage First
- 新生代和老年代由一个个region区组成；
- 可以独立完成所有区域的内存回收；
- 标记-整理算法；

#### G1的工作过程：
1. 初始标记：同CMS；
2. 并发标记：耗时较长，分析GC Root到所有对象的可达性。JVM是使用Remembered Set保存了对象引用的调用信息，在可达性分析的时候只需要同时遍历remembered set；
3. 最终标记：通过Remembered Set日志来记录并发标记时没有记录到的用户线程，在这个阶段将改变合并到Remembered Set中，完成最终标记。
4. 筛选清除：通过标记整理的算法，根据用户配置的回收时间，和维护的优先级列表，优先收集价值最大的region。收集阶段是基于标记-整理和复制算法；



### ZGC

- JDK11中发布的最新垃圾收集器；
- 没有分代概念、时间可控，超大堆；
- 几乎所有阶段都是并发执行；
- 动态的创建销毁Region

#### 回收过程
1. 初始停顿标记：停顿JVM，标记存活对象；
2. 并发标记：并发递归标记其他对象；
3. 移动对象：找到过期对象，移动到新的Region，然后压缩老的Region；
4. 修正指针：将指针指向新的地址；